<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>raga.fm - Cast Receiver</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/15.0.4/Tone.js"></script>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: black;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        #status {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 8px;
            font-size: 14px;
            z-index: 1000;
        }
        #raga-info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 8px;
            z-index: 1000;
        }
        #raga-info h2 {
            margin: 0 0 10px 0;
            font-size: 24px;
        }
        #raga-info p {
            margin: 5px 0;
            font-size: 14px;
            opacity: 0.8;
        }
    </style>
  </head>
  <body>
    <div id="status">Connecting...</div>
    <div id="raga-info" style="display: none;">
        <h2 id="raga-name">Raga Name</h2>
        <p id="raga-mood">Mood</p>
        <p id="raga-time">Time Slot</p>
        <p id="current-mode">Mode: Ambient</p>
    </div>

    <script src="https://www.gstatic.com/cast/sdk/libs/caf_receiver/v3/cast_receiver_framework.js"></script>
    <script>
        // Cast Receiver State
        let castReceiverContext;
        let playerManager;
        let playbackConfig;
        
        // Audio/Visual State
        let receivedState = null;
        let isReceiving = false;
        let lastUpdateTime = 0;
        
        // Audio components (will be initialized when state is received)
        let melodySampler, stringSampler, kotoSampler, chordSampler, chordSamplerC, drumSampler, hiHatSampler, tablaPlayers;
        let reverb, delay, lowPassFilter, hiHatDelay, hiHatReverb, meter;
        let assetsLoaded = false;
        
        // Visual components
        let grid = [];
        let gridCols, cellSize;
        let noteCells = {};
        let textCanvas;
        let backgroundShader;
        let shaderTime = 0;
        let hindiFont;
        let currentAmplitude = 0;
        let currentMode = 'ambient';
        
        // Playback state
        let isPlaying = false;
        let bpm = 120;
        let beatDuration;
        let playbackLoopTimeout;
        let currentRaga = null;
        let currentSequence = [];
        let currentBeat = 0;
        let barCounter = 0;
        
        // Initialize Cast Receiver
        function initializeCastReceiver() {
            castReceiverContext = cast.framework.CastReceiverContext.getInstance();
            playerManager = castReceiverContext.getPlayerManager();
            
            // Configure playback
            playbackConfig = new cast.framework.PlaybackConfig();
            playbackConfig.licenseRequestHandler = requestInfo => {
                requestInfo.withCredentials = false;
            };
            
            // Listen for custom messages from sender
            castReceiverContext.addCustomMessageListener('urn:x-cast:raga-fm', (customEvent) => {
                console.log('Received custom message:', customEvent.data);
                handleCustomMessage(customEvent.data);
            });
            
            // Listen for player events
            playerManager.addEventListener(cast.framework.events.EventType.LOAD, (event) => {
                console.log('Load event received');
                updateStatus('Loading content...');
            });
            
            playerManager.addEventListener(cast.framework.events.EventType.PLAY, (event) => {
                console.log('Play event received');
                updateStatus('Playing');
                startPlayback();
            });
            
            playerManager.addEventListener(cast.framework.events.EventType.PAUSE, (event) => {
                console.log('Pause event received');
                updateStatus('Paused');
                stopPlayback();
            });
            
            // Start the receiver
            castReceiverContext.start();
            updateStatus('Ready to cast');
        }
        
        function handleCustomMessage(data) {
            try {
                if (data.type === 'STATE_UPDATE') {
                    receivedState = data.state;
                    updateVisualState(receivedState);
                    updateAudioState(receivedState);
                    isReceiving = true;
                    lastUpdateTime = Date.now();
                } else if (data.type === 'RAGA_CHANGE') {
                    setCurrentRaga(data.raga);
                } else if (data.type === 'MODE_CHANGE') {
                    setCurrentMode(data.mode);
                } else if (data.type === 'PLAYBACK_STATE') {
                    if (data.playing && !isPlaying) {
                        startPlayback();
                    } else if (!data.playing && isPlaying) {
                        stopPlayback();
                    }
                }
            } catch (error) {
                console.error('Error handling custom message:', error);
            }
        }
        
        function updateStatus(message) {
            document.getElementById('status').textContent = message;
        }
        
        function setCurrentRaga(raga) {
            currentRaga = raga;
            document.getElementById('raga-name').textContent = raga.name;
            document.getElementById('raga-mood').textContent = `Mood: ${raga.mood}`;
            document.getElementById('raga-time').textContent = `Time: ${raga.time_slot}`;
            document.getElementById('raga-info').style.display = 'block';
        }
        
        function setCurrentMode(mode) {
            currentMode = mode;
            document.getElementById('current-mode').textContent = `Mode: ${mode.charAt(0).toUpperCase() + mode.slice(1)}`;
        }
        
        function updateVisualState(state) {
            if (state.currentPlayingNote) {
                currentPlayingNote = state.currentPlayingNote;
            }
            if (state.shaderTime !== undefined) {
                shaderTime = state.shaderTime;
            }
            if (state.currentAmplitude !== undefined) {
                currentAmplitude = state.currentAmplitude;
            }
            if (state.grid) {
                // Update grid state for interaction mode
                grid = state.grid;
            }
        }
        
        function updateAudioState(state) {
            if (state.bpm) {
                bpm = state.bpm;
                beatDuration = 60000 / bpm;
            }
            if (state.currentBeat !== undefined) {
                currentBeat = state.currentBeat;
            }
            if (state.barCounter !== undefined) {
                barCounter = state.barCounter;
            }
            if (state.currentSequence) {
                currentSequence = state.currentSequence;
            }
        }
        
        function startPlayback() {
            isPlaying = true;
            updateStatus('Playing - Syncing with sender...');
        }
        
        function stopPlayback() {
            isPlaying = false;
            clearTimeout(playbackLoopTimeout);
            updateStatus('Paused');
        }
        
        // Initialize when page loads
        window.addEventListener('load', initializeCastReceiver);
    </script>
    
    <!-- P5.js sketch will be loaded after receiver is initialized -->
    <script>
        // P5.js sketch for visual rendering
        let ragaData = null;
        
        // Sample maps (simplified versions for receiver)
        const simpleSampleMaps = {
            rhodes: { 'C4': 'samples/jRhodes3d-mono/A_062__D4_1.flac' },
            strings: { 'C4': 'samples/Strings1/c4_Pick1.flac' },
            koto: { 'C4': 'samples/sustain/Front_c4_Sustain1.flac' },
            drums: { 'kick': 'samples/drums/Ghosthack-Kick_01.wav' },
            tabla: { 'dha': 'samples/TABLA/Tabla_Flare_1.wav' }
        };
        
        function preload() {
            // Load basic assets for receiver
            backgroundShader = loadShader('background.vert', 'background.frag');
            hindiFont = loadFont('fonts/ome_bhatkhande_hindi.ttf');
        }
        
        function setup() {
            createCanvas(windowWidth, windowHeight, WEBGL);
            
            textCanvas = createGraphics(windowWidth, windowHeight);
            textCanvas.textFont(hindiFont);
            
            // Initialize basic audio components
            reverb = new Tone.Reverb({ decay: 4, wet: 0.7 });
            delay = new Tone.FeedbackDelay({ delayTime: "8n", feedback: 0.5, wet: 0.5 });
            lowPassFilter = new Tone.Filter({ frequency: 2000, type: 'lowpass', Q: 1 });
            meter = new Tone.Meter();
            Tone.getDestination().connect(meter);
            
            // Create simplified samplers for receiver
            melodySampler = new Tone.Sampler(simpleSampleMaps.rhodes).chain(lowPassFilter, delay, reverb, Tone.Destination);
            
            assetsLoaded = true;
            updateStatus('Ready for content');
        }
        
        function draw() {
            if (!assetsLoaded || !currentRaga) {
                background(0);
                return;
            }
            
            // Update amplitude from audio
            if (meter) {
                let level_dB = meter.getValue();
                currentAmplitude = map(level_dB, -48, 0, 0, 1, true);
            }
            
            // Render background shader
            if (backgroundShader) {
                ortho(-width / 2, width / 2, height / 2, -height / 2, 0, 1000);
                shader(backgroundShader);
                
                backgroundShader.setUniform('iResolution', [width, height]);
                backgroundShader.setUniform('iTime', shaderTime);
                
                if (currentRaga.colorScheme) {
                    const scheme = currentRaga.colorScheme;
                    let c;
                    c = color(scheme.background);
                    backgroundShader.setUniform('u_color_background', [red(c) / 255.0, green(c) / 255.0, blue(c) / 255.0]);
                    c = color(scheme.primary);
                    backgroundShader.setUniform('u_color_primary', [red(c) / 255.0, green(c) / 255.0, blue(c) / 255.0]);
                    c = color(scheme.secondary);
                    backgroundShader.setUniform('u_color_secondary', [red(c) / 255.0, green(c) / 255.0, blue(c) / 255.0]);
                    c = color(scheme.accent);
                    backgroundShader.setUniform('u_color_accent', [red(c) / 255.0, green(c) / 255.0, blue(c) / 255.0]);
                }
                
                noStroke();
                rect(-width/2, -height/2, width, height);
                
                // Draw grid if in interaction mode
                if (currentMode === 'interaction' && grid.length > 0) {
                    drawGridOverlay();
                }
            }
            
            // Update shader time
            shaderTime += 0.016; // 60fps increment
        }
        
        function drawGridOverlay() {
            // Simplified grid rendering for receiver
            textCanvas.clear();
            textCanvas.fill(255, 200);
            textCanvas.textAlign(CENTER, CENTER);
            textCanvas.textSize(16);
            
            for (let row = 0; row < grid.length; row++) {
                for (let col = 0; col < grid[row].length; col++) {
                    const cell = grid[row][col];
                    if (cell && cell.note) {
                        const x = col * cellSize + cellSize / 2;
                        const y = row * cellSize + cellSize / 2;
                        
                        // Highlight playing cells
                        if (cell.isPlaying) {
                            textCanvas.fill(255, 255, 0, 200);
                        } else {
                            textCanvas.fill(255, 150);
                        }
                        
                        textCanvas.text(cell.hindiNote || cell.note, x, y);
                    }
                }
            }
            
            image(textCanvas, -width / 2, height / 2, width, -height);
        }
        
        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            textCanvas.resizeCanvas(windowWidth, windowHeight);
            textCanvas.textFont(hindiFont);
        }
    </script>
  </body>
</html> 